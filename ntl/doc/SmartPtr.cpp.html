<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>/Volumes/Unix/unix-files.noindex/ntl-new/ntl-9.6.0/doc/SmartPtr.cpp.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v6">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css">
<style type="text/css">
<!--
pre { font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
.Constant { color: #ff8c00; }
.Statement { color: #b03060; font-weight: bold; }
.Type { color: #008b00; font-weight: bold; }
.Comment { color: #0000ee; font-style: italic; }
-->
</style>
</head>
<body>
<pre>


<span class="Comment">/*</span><span class="Comment">***************************************************************************</span>

<span class="Comment">SmartPtr: a smart pointer class.</span>

<span class="Comment">Synopsis: provides a reference counted smart pointer, similar to shared_ptr</span>
<span class="Comment">in the standard library.  It is provided here to minimize reliance</span>
<span class="Comment">on the standard library, especially for older C++ compilers, which may</span>
<span class="Comment">not provide shared_ptr, or it may be in TR1, which gets messy.</span>


<span class="Comment">Examples:</span>


<span class="Comment">  SmartPtr&lt;T&gt; p1;         // initialize to null</span>
<span class="Comment">  SmartPtr&lt;T&gt; p2 = 0;</span>

<span class="Comment">  SmartPtr&lt;T&gt; p3(p1);     // copy constructor</span>

<span class="Comment">  T *rp;</span>
<span class="Comment">  SmartPtr&lt;T&gt; p4(rp);     // construct using raw pointer (explicit): better </span>
<span class="Comment">                          // to use MakeSmart below</span>

<span class="Comment">  p1 = MakeSmart&lt;T&gt;(...); // build new T object by invoking constructor</span>
<span class="Comment">                          // T(...) with pseudo-variadic templates.</span>
<span class="Comment">                          // This is safer and more efficient that</span>
<span class="Comment">                          // using the raw-pointer constructor</span>
<span class="Comment">                        </span>
<span class="Comment">  p1 = p2;                // assignment</span>
<span class="Comment">  p1 = 0;                 // assign null</span>


<span class="Comment">  if (!p1) ...            //  test for null</span>
<span class="Comment">  if (p1 == 0) ... </span>

<span class="Comment">  if (p1) ...             // test for not null ... </span>
<span class="Comment">  if (p1 != 0) ... </span>

<span class="Comment">  if (p1 == p2) ...       // test for equality </span>
<span class="Comment">  if (p1 != p2) </span>

<span class="Comment">  *p1                     // dereferencing</span>
<span class="Comment">  p1-&gt;...</span>

<span class="Comment">  p1.get();               // return the underlying raw pointer...dangerous!</span>

<span class="Comment">  p1.swap(p2);            // fast swap</span>
<span class="Comment">  swap(p1, p2);</span>


<span class="Comment">Automatic Conversions:</span>

<span class="Comment">If S is another class, SmartPtr&lt;S&gt; converts to SmartPtr&lt;T&gt; if S* converts to T*</span>
<span class="Comment">(for example, if S is a subclass of T).  Similarly, SmartPtr&lt;S&gt; and SmartPtr&lt;T&gt;</span>
<span class="Comment">may be compared if S* and T* may be compared.</span>

<span class="Comment">MakeSmart:</span>

<span class="Comment">One can write SmartPtr&lt;T&gt; p = MakeSmart&lt;T&gt;(x1, ..., xn), and this will create a</span>
<span class="Comment">smart pointer to an object constructed as T(x1, ..., xn).  Besides notational</span>
<span class="Comment">convenience, it also reduces the number of memory allocations from 2 to 1, as</span>
<span class="Comment">the data and control block can be allocated in one chunck of memory.</span>

<span class="Comment">This is implemented without reliance on C++11 features, which means that there</span>
<span class="Comment">are limitations.  First, the number n of arguments is limited to 9.  And</span>
<span class="Comment">second, all arguments are pass by const reference. However, you can work around</span>
<span class="Comment">this by using the helper function Fwd.  For example, if T has a 2-argument</span>
<span class="Comment">constructor where the second must be a non-const reference of some type, and x2</span>
<span class="Comment">is a variable of that type, you can write MakeSmart&lt;T&gt;(x1, Fwd(x2)), to forward</span>
<span class="Comment">that reference through all the template nonsense in a typesafe manner.</span>

<span class="Comment">MakeRaw:</span>

<span class="Comment">One can also write T *p = MakeRaw&lt;T&gt;(x1, ..., xn) to create a </span>
<span class="Comment">raw pointer.  This is the same as writing T *p = new T(x1, ..., xn),</span>
<span class="Comment">except that error handling is determined by the NTL_EXCEPTION</span>
<span class="Comment">flag (on =&gt; bad_alloc exception is thrown, off =&gt; error message</span>
<span class="Comment">and abort).</span>

<span class="Comment">MakeRawArray:</span>

<span class="Comment">Another utility routine: one can write T *p = MakeRawArray&lt;T&gt;(n)</span>
<span class="Comment">to make a plain array of n T objects.  Error handling is the same</span>
<span class="Comment">as for MakeRaw.</span>

<span class="Comment">Dynamic casting:</span>

<span class="Comment">I've also supplied a dynamic cast operation for smart pointers.</span>

<span class="Comment">   SmartPtr&lt;Derived&gt; d = MakeSmart&lt;Derived&gt;(); // d points to Derived</span>
<span class="Comment">   SmartPtr&lt;Base&gt; b = d; // implicit upcast: OK</span>

<span class="Comment">   SmartPtr&lt;Derived&gt; d1 = DynamicCast&lt;Derived&gt;(b);</span>
<span class="Comment">      // downcast to a Derived object -- returns null for a bad cast</span>
<span class="Comment">   </span>



<span class="Comment">Implementation notes:</span>

<span class="Comment">If NTL is compiled with the NTL_THREADS option, then the reference counting</span>
<span class="Comment">will be thread safe.</span>

<span class="Comment">The SmartPtrControl class heirarchy is used to make sure the right destructor</span>
<span class="Comment">is called when the ref count goes to zero.  This can be an issue for forward</span>
<span class="Comment">declared classes and for subclasses.  For example, if T is forward declared in</span>
<span class="Comment">a context where the ref count goes to zero, or if the object's actual type is a</span>
<span class="Comment">subclass of T and T's destructor was not declared virtual.  The implementation</span>
<span class="Comment">of SmartPtr guarantees correct behavior in these situations.</span>

<span class="Comment">The null tests p, !p, p == 0, are all effected via an implicit conversion from</span>
<span class="Comment">SmartPtr&lt;T&gt; to a funny pointer type (a pointer to a member function, which</span>
<span class="Comment">avoids other, unwanted implicit conversions: this is the so-called &quot;safe bool</span>
<span class="Comment">idiom&quot;);</span>

<span class="Comment">Also, there is an implicit conversion from the same, funny pointer type to</span>
<span class="Comment">SmartPtr&lt;T&gt;, which is how one can use 0 to initialize and assign to a</span>
<span class="Comment">SmartPtr&lt;T&gt;.</span>

<span class="Comment">In C++11 both of the above effects could perhaps be achieved more directly.</span>
<span class="Comment">The new &quot;explict bool&quot; operator can replace the &quot;safe bool idiom&quot;, and I would</span>
<span class="Comment">think that the new null pointer could be used to get the conversion from &quot;0&quot; to</span>
<span class="Comment">work.</span>

<span class="Comment">NOTES: See <a href="http://www.artima.com/cppsource/safebool.html">http://www.artima.com/cppsource/safebool.html</a> for more on the &quot;safe</span>
<span class="Comment">bool idiom&quot;.  </span>

<span class="Comment"> </span>


<span class="Comment">****************************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> SmartPtr {
<span class="Statement">public</span>:
   <span class="Type">explicit</span> SmartPtr(T* p);
   <span class="Comment">// construct smart pointer from raw pointer (allocated with new)</span>
   <span class="Comment">// EXCEPTIONS: a control block is dynamically allocated;</span>
   <span class="Comment">//    if this allocation fails, the object pointed to by p is destroyed</span>
   <span class="Comment">//    and a bad_alloc exception is thrown</span>

   SmartPtr();
   <span class="Comment">// initial value null</span>

   ~SmartPtr();
   <span class="Comment">// if ref count drops to zero, then delete referent</span>

   SmartPtr(<span class="Type">const</span> SmartPtr&amp; other);
   SmartPtr&amp; <span class="Statement">operator</span>=(<span class="Type">const</span> SmartPtr&amp; other);
   <span class="Comment">// copy and asignment</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; SmartPtr(<span class="Type">const</span> SmartPtr&lt;Y&gt;&amp; other);
   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; SmartPtr&amp; <span class="Statement">operator</span>=(<span class="Type">const</span> SmartPtr&lt;Y&gt;&amp; other);
   <span class="Comment">// copy and asignment</span>

   T&amp; <span class="Statement">operator</span>*()  <span class="Type">const</span>;
   T* <span class="Statement">operator</span>-&gt;() <span class="Type">const</span>;
   <span class="Comment">// indirection</span>

   T* get() <span class="Type">const</span>;
   <span class="Comment">// get underlying raw pointer</span>

   <span class="Type">void</span> swap(SmartPtr&amp; other);

   SmartPtr(fake_null_type);
   <span class="Comment">// allows assignment and initialization from 0</span>

   <span class="Statement">operator</span> fake_null_type() <span class="Type">const</span>;
   <span class="Comment">// allows comparisons to 0</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; SmartPtr&lt;Y&gt; DynamicCast() <span class="Type">const</span>;
};


<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(SmartPtr&lt;T&gt;&amp; p, SmartPtr&lt;T&gt;&amp; q);

<span class="Comment">// free dynamic cast function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt; SmartPtr&lt;X&gt; DynamicCast(<span class="Type">const</span> SmartPtr&lt;Y&gt;&amp; p);


<span class="Comment">// Equality testing</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt;
<span class="Type">bool</span> <span class="Statement">operator</span>==(<span class="Type">const</span> SmartPtr&lt;X&gt;&amp; a, <span class="Type">const</span> SmartPtr&lt;Y&gt;&amp; b);

<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt;
<span class="Type">bool</span> <span class="Statement">operator</span>!=(<span class="Type">const</span> SmartPtr&lt;X&gt;&amp; a, <span class="Type">const</span> SmartPtr&lt;Y&gt;&amp; b);

<span class="Comment">// MakeSmart psuedo-variadic template</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T, <span class="Type">class</span> X1, ..., <span class="Type">class</span> Xn&gt;
SmartPtr&lt;T&gt; MakeSmart(<span class="Type">const</span> X1&amp; x1, ..., <span class="Type">const</span> Xn&amp; xn);
<span class="Comment">// EXCEPTIONS: may throw if dynamic constrction of T(x1, ..., xn) fails</span>


<span class="Comment">// EXCEPTIONS: unless otherwise specified, the methods above</span>
<span class="Comment">// never throw an exception (under C++11 rules, if a destructor</span>
<span class="Comment">// is invoked that throws an exception, the program will terminate).</span>


<span class="Comment">/*</span><span class="Comment">***************************************************************************</span>

<span class="Comment">Experimantal: CloneablePtr&lt;T&gt; ...essentially same interface as SmartPtr, but </span>
<span class="Comment">allows cloning of complete objects.  The differences:</span>
<span class="Comment">*  must construct using MakeCloneable</span>
<span class="Comment">*  a clone method is provided</span>
<span class="Comment">*  implicit conversion from CloneablePtr to SmartPtr is allowed</span>

<span class="Comment">Example:</span>

<span class="Comment">   CloneablePtr&lt;Derived&gt; d = MakeCloneable&lt;Derived&gt;(); </span>
<span class="Comment">   // d points to Derived</span>

<span class="Comment">   CloneablePtr&lt;Base&gt; b = d; // implicit upcast: OK</span>

<span class="Comment">   CloneablePtr&lt;Base&gt; b1 = b.clone(); </span>
<span class="Comment">   // clone of b, which is really a Derived object</span>

<span class="Comment">   CloneablePtr&lt;Derived&gt; d1 = DynamicCast&lt;Derived&gt;(b1);</span>
<span class="Comment">   // downcast to a Derived object -- returns null for a bad cast</span>

<span class="Comment">   SmartPtr&lt;Base&gt; b2 = d1;</span>
<span class="Comment">   </span>


<span class="Comment">Implementation:</span>

<span class="Comment">In the clone method, the object is constructed using the copy constructor for</span>
<span class="Comment">the type T, where T is the compile-time type with which the first smart pointer</span>
<span class="Comment">to this object was was created, even if the pointer has been subsequently</span>
<span class="Comment">upcasted to a base type S.  Such objects must have been initially created using</span>
<span class="Comment">the MakeCloneable function.  It turns out, this is hard to do in a completely</span>
<span class="Comment">standards-compliant way, because of the type erasure going on.  So I settled on</span>
<span class="Comment">the current method, which does some low-level pointer arithmetic.  Even with</span>
<span class="Comment">fancy things like multiple and virtual inheritance, it should work, under the</span>
<span class="Comment">assumption that if two objects have the same (runtime) type, then their memory</span>
<span class="Comment">layout is the same.  I don't think anything like that is guaranteed by the</span>
<span class="Comment">standard, but this seems reasonable, and it seems to work.  Like I said, it is</span>
<span class="Comment">experimental, and I would appreciate feedback from C++ gurus.</span>

<span class="Comment">Note that NTL does not use this feature, but I do have applications where this</span>
<span class="Comment">is convenient.</span>


<span class="Comment">*********************************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> CloneablePtr {
<span class="Statement">public</span>:
   CloneablePtr();
   <span class="Comment">// initial value null</span>

   ~CloneablePtr();
   <span class="Comment">// if ref count drops to zero, then delete referent</span>

   CloneablePtr(<span class="Type">const</span> CloneablePtr&amp; other);
   CloneablePtr&amp; <span class="Statement">operator</span>=(<span class="Type">const</span> CloneablePtr&amp; other);
   <span class="Comment">// copy and asignment</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; CloneablePtr(<span class="Type">const</span> CloneablePtr&lt;Y&gt;&amp; other);
   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; CloneablePtr&amp; <span class="Statement">operator</span>=(<span class="Type">const</span> CloneablePtr&lt;Y&gt;&amp; other);
   <span class="Comment">// copy and asignment</span>

   T&amp; <span class="Statement">operator</span>*()  <span class="Type">const</span>;
   T* <span class="Statement">operator</span>-&gt;() <span class="Type">const</span>;
   <span class="Comment">// indirection</span>

   T* get() <span class="Type">const</span>;
   <span class="Comment">// get underlying raw pointer</span>

   <span class="Type">void</span> swap(CloneablePtr&amp; other);

   CloneablePtr(fake_null_type);
   <span class="Comment">// allows assignment and initialization from 0</span>

   <span class="Statement">operator</span> fake_null_type() <span class="Type">const</span>;
   <span class="Comment">// allows comparisons to 0</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; CloneablePtr&lt;Y&gt; DynamicCast() <span class="Type">const</span>;

   CloneablePtr clone() <span class="Type">const</span>;
   <span class="Comment">// construct a clone, using the copy constructor</span>
   <span class="Comment">// EXCEPTIONS: may throw if copy construction fails</span>


   <span class="Type">template</span>&lt;<span class="Type">class</span> Y&gt; <span class="Statement">operator</span> SmartPtr&lt;Y&gt;();
   <span class="Comment">// implicit conversion from CloneablePtr&lt;T&gt; to SmartPtr&lt;Y&gt;,</span>
   <span class="Comment">// allowed if T* converts implicitly to Y*.</span>
};


<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(CloneablePtr&lt;T&gt;&amp; p, CloneablePtr&lt;T&gt;&amp; q);

<span class="Comment">// free dynamic cast function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt; CloneablePtr&lt;X&gt; DynamicCast(<span class="Type">const</span> CloneablePtr&lt;Y&gt;&amp; p);


<span class="Comment">// Equality testing</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt;
<span class="Type">bool</span> <span class="Statement">operator</span>==(<span class="Type">const</span> CloneablePtr&lt;X&gt;&amp; a, <span class="Type">const</span> CloneablePtr&lt;Y&gt;&amp; b);

<span class="Type">template</span>&lt;<span class="Type">class</span> X, <span class="Type">class</span> Y&gt;
<span class="Type">bool</span> <span class="Statement">operator</span>!=(<span class="Type">const</span> CloneablePtr&lt;X&gt;&amp; a, <span class="Type">const</span> CloneablePtr&lt;Y&gt;&amp; b);

<span class="Comment">// MakeCloneable psuedo-variadic template</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T, <span class="Type">class</span> X1, ..., <span class="Type">class</span> Xn&gt;
CloneablePtr&lt;T&gt; MakeCloneable(<span class="Type">const</span> X1&amp; x1, ..., <span class="Type">const</span> Xn&amp; xn);
<span class="Comment">// EXCEPTIONS: may throw if dynamic constrction of T(x1, ..., xn) fails</span>


<span class="Comment">// EXCEPTIONS: unless otherwise specified, the methods above</span>
<span class="Comment">// never throw an exception (under C++11 rules, if a destructor</span>
<span class="Comment">// is invoked that throws an exception, the program will terminate).</span>






<span class="Comment">/*</span><span class="Comment">*********************************************************************</span>

<span class="Comment">UniquePtr&lt;T&gt; -- unique pointer to object with copying disabled.</span>
<span class="Comment">Useful for pointers inside classes so that we can</span>
<span class="Comment">automatically destruct them.  </span>

<span class="Comment">Constructors:</span>
<span class="Comment">   UniquePtr&lt;T&gt; p1;     // initialize with null</span>

<span class="Comment">   T* rp;</span>
<span class="Comment">   UniquePtr&lt;T&gt; p1(rp); // construct using raw pointer (explicit)</span>

<span class="Comment">   p1 = 0;              // destroy's p1's referent and assigns null</span>

<span class="Comment">   p1.make(...);        // destroy's p1's referent and assigns</span>
<span class="Comment">                        // a fresh objected constructed via T(...),</span>
<span class="Comment">                        // using psuedo-variadic templates</span>
<span class="Comment">                </span>
<span class="Comment">   p1.reset(rp);        // destroy's p1's referent and assign rp</span>

<span class="Comment">   if (!p1) ...         // test for null</span>
<span class="Comment">   if (p1 == 0) ...</span>

<span class="Comment">   if (p1) ...          // test for nonnull</span>
<span class="Comment">   if (p1 != 0) ...</span>

<span class="Comment">   if (p1 == p2) ...    // test for equality</span>
<span class="Comment">   if (p1 != p2) ...   </span>

<span class="Comment">   *p1                  // dereferencing</span>
<span class="Comment">   p1-&gt;...</span>


<span class="Comment">   rp = p1.get();       // fetch raw pointer</span>
<span class="Comment">   rp = p1.release();   // fetch raw pointer, and set to null</span>

<span class="Comment">   p1.move(p2);         // move p2 to p1, destroying p1's referent</span>
<span class="Comment">                        //   if p1 != p2</span>

<span class="Comment">   p1.swap(p2);         // swap pointers</span>
<span class="Comment">   swap(p1, p2);</span>

<span class="Comment">   </span>
<span class="Comment">*********************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> UniquePtr {
<span class="Statement">public</span>:
   <span class="Type">explicit</span> UniquePtr(T *p);
   <span class="Comment">// construct UniquePtr from raw pointer (allocated with new)</span>

   UniquePtr();
   <span class="Comment">// initial value is null</span>

   ~UniquePtr();
   <span class="Comment">// destroys referent</span>

   <span class="Type">void</span> reset(T* p = <span class="Constant">0</span>);
   <span class="Comment">// reset underlying pointer to p, destroying original referent</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> T, <span class="Type">class</span> X1, ..., <span class="Type">class</span> Xn&gt;
   <span class="Type">void</span> make(<span class="Type">const</span> X1&amp; x1, ..., <span class="Type">const</span> Xn&amp; xn);
   <span class="Comment">// pseudo-variadic template, roughly equivalent to</span>
   <span class="Comment">// reset(new T(x1, ..., xn))</span>
   <span class="Comment">// EXCEPTIONS: this may throw (but provides strong ES guarantee)</span>

   T&amp; <span class="Statement">operator</span>*()  <span class="Type">const</span>;
   T* <span class="Statement">operator</span>-&gt;() <span class="Type">const</span>;
   <span class="Comment">// indirection</span>

   T* get() <span class="Type">const</span>;
   <span class="Comment">// get raw pointer</span>

   T* release();
   <span class="Comment">// returns raw pointer, and sets the raw pointer to null</span>

   <span class="Type">void</span> move(UniquePtr&amp; other);
   <span class="Comment">// move other to *this</span>

   <span class="Type">void</span> swap(UniquePtr&amp; other);
   <span class="Comment">// swap raw pointers</span>

   UniquePtr&amp; <span class="Statement">operator</span>=(fake_null_type);
   UniquePtr(fake_null_type);
   <span class="Comment">// allows initialization and assignment of 0</span>

   <span class="Statement">operator</span> fake_null_type() <span class="Type">const</span>;
   <span class="Comment">// allows comparison with 0</span>

<span class="Statement">private</span>:
   UniquePtr(<span class="Type">const</span> UniquePtr&amp;); <span class="Comment">// disabled</span>
   <span class="Type">void</span> <span class="Statement">operator</span>=(<span class="Type">const</span> UniquePtr&amp;); <span class="Comment">// disabled</span>
};


<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(UniquePtr&lt;T&gt;&amp; p, UniquePtr&lt;T&gt;&amp; q);



<span class="Comment">// Equality testing</span>

<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>==(<span class="Type">const</span> UniquePtr&lt;X&gt;&amp; a, <span class="Type">const</span> UniquePtr&lt;X&gt;&amp; b);
<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>!=(<span class="Type">const</span> UniquePtr&lt;X&gt;&amp; a, <span class="Type">const</span> UniquePtr&lt;X&gt;&amp; b);


<span class="Comment">// EXCEPTIONS: unless otherwise specified, the methods above</span>
<span class="Comment">// never throw an exception (under C++11 rules, if a destructor</span>
<span class="Comment">// is invoked that throws an exception, the program will terminate).</span>


<span class="Comment">/*</span><span class="Comment">*********************************************************************</span>

<span class="Comment">OptionalVal&lt;T&gt; -- unique pointer to object with copying enabled.</span>

<span class="Comment">Constructors:</span>
<span class="Comment">   OptionalVal&lt;T&gt; p1;     // initialize with null</span>

<span class="Comment">   T* rp;</span>
<span class="Comment">   OptionalVal&lt;T&gt; p1(rp); // construct using raw pointer (explicit)</span>

<span class="Comment">   OptionalVal&lt;T&gt; p2(p1); // construct a copy of p1's referent</span>

<span class="Comment">    </span>

<span class="Comment">   p1.make(...);        // destroy's p1's referent and assigns</span>
<span class="Comment">                        // a fresh objected constructed via T(...),</span>
<span class="Comment">                        // using psuedo variadic templates</span>
<span class="Comment">                </span>
<span class="Comment">   p1.reset(rp);        // destroy's p1's referent and assign rp</span>

<span class="Comment">   if (p1.exists()) ... // test for null</span>

<span class="Comment">   p1.val()             // dereference</span>

<span class="Comment">   p1.move(p2);         // move p2 to p1, destroying p1's referent</span>
<span class="Comment">                        //   if p1 != p2</span>

<span class="Comment">   p1 = p2;             // deep copy, using T's copy constructor</span>

<span class="Comment">   p1.swap(p2);         // swap pointers</span>
<span class="Comment">   swap(p1, p2);</span>

<span class="Comment">   </span>
<span class="Comment">*********************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> OptionalVal {
<span class="Statement">public</span>:
   <span class="Type">explicit</span> OptionalVal(T *p);
   <span class="Comment">// initialize using raw pointer (allocated with new)</span>

   OptionalVal();
   <span class="Comment">// initialize to null</span>

   OptionalVal(<span class="Type">const</span> OptionalVal&amp; other);
   <span class="Comment">// initialize using a deep copy (via T's copy constructor)</span>

   OptionalVal&amp; <span class="Statement">operator</span>=(<span class="Type">const</span> OptionalVal&amp; other);
   <span class="Comment">// assignment using a deep copy (via T's copy constructor)</span>

   ~OptionalVal();
   <span class="Comment">// destroys the referent</span>

   <span class="Type">void</span> reset(T* p = <span class="Constant">0</span>);
   <span class="Comment">// resets the referent</span>

   <span class="Type">template</span>&lt;<span class="Type">class</span> T, <span class="Type">class</span> X1, ..., <span class="Type">class</span> Xn&gt;
   <span class="Type">void</span> make(<span class="Type">const</span> X1&amp; x1, ..., <span class="Type">const</span> Xn&amp; xn);
   <span class="Comment">// pseudo-variadic template.</span>
   <span class="Comment">// resets the referent to a new object T(x1, ..., xn)</span>
   <span class="Comment">// EXCEPTIONS: may throw an exception (but provides strong ES guarantee)</span>

   T&amp; val() <span class="Type">const</span>;
   <span class="Comment">// returns reference to referent </span>
   <span class="Comment">// if underlying pointer p is null, the indirection *p</span>
   <span class="Comment">// is undefined behavior, but most likely leads to program termination</span>

   <span class="Type">bool</span> exists() <span class="Type">const</span>;
   <span class="Comment">// checks that underlying pointer is not null</span>

   <span class="Type">void</span> move(OptionalVal&amp; other);
   <span class="Comment">// performs a (shallow) pointer move</span>

   <span class="Type">void</span> swap(OptionalVal&amp; other);
   <span class="Comment">// performs a (shallow) pointer swap</span>

};


<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(OptionalVal&lt;T&gt;&amp; p, OptionalVal&lt;T&gt;&amp; q);



<span class="Comment">// EXCEPTIONS: unless otherwise specified, the methods above</span>
<span class="Comment">// never throw an exception (under C++11 rules, if a destructor</span>
<span class="Comment">// is invoked that throws an exception, the program will terminate).</span>



<span class="Comment">/*</span><span class="Comment">*********************************************************************</span>

<span class="Comment">UniqueArray&lt;T&gt; -- unique pointer to array of objects with copying disabled.</span>
<span class="Comment">Useful for pointers inside classes so that we can</span>
<span class="Comment">automatically destruct them.  </span>

<span class="Comment">Constructors:</span>
<span class="Comment">   UniqueArray&lt;T&gt; p1;     // initialize with null</span>

<span class="Comment">   T* rp;</span>
<span class="Comment">   UniqueArray&lt;T&gt; p1(rp); // construct using raw pointer (explicit)</span>

<span class="Comment">   p1 = 0;              // destroy's p1's referent and assigns null</span>

<span class="Comment">   p1.SetLength(n);     // destroy's p1's referent and assigns</span>
<span class="Comment">                        // a fresh objected constructed via new T[n]</span>
<span class="Comment">                </span>
<span class="Comment">   p1.reset(rp);        // destroy's p1's referent and assign rp</span>

<span class="Comment">   if (!p1) ...         // test for null</span>
<span class="Comment">   if (p1 == 0) ...</span>

<span class="Comment">   if (p1) ...          // test for nonnull</span>
<span class="Comment">   if (p1 != 0) ...</span>

<span class="Comment">   if (p1 == p2) ...    // test for equality</span>
<span class="Comment">   if (p1 != p2) ...   </span>

<span class="Comment">   p1[i]                // array indexing</span>

<span class="Comment">   rp = p1.get();       // fetch raw pointer</span>
<span class="Comment">   rp = p1.release();   // fetch raw pointer, and set to null</span>
<span class="Comment">   p1.move(p2);         // move p2 to p1, destroying p1's referent </span>
<span class="Comment">                        //   if p1 != p2</span>

<span class="Comment">   p1.swap(p2);         // fast swap</span>
<span class="Comment">   swap(p1, p2);</span>

<span class="Comment">   </span>
<span class="Comment">*********************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> UniqueArray {
<span class="Statement">public</span>:
   <span class="Type">explicit</span> UniqueArray(T *p);
   <span class="Comment">// construct from raw pointer (allocated with new[])</span>

   UniqueArray();
   <span class="Comment">// initially null</span>

   ~UniqueArray();

   <span class="Type">void</span> reset(T* p = <span class="Constant">0</span>);
   <span class="Comment">// reset with raw pointer, destryong referent</span>

   <span class="Type">void</span> SetLength(<span class="Type">long</span> n);
   <span class="Comment">// destroys referent and allocates an array of size n</span>
   <span class="Comment">// EXCEPTIONS: this may throw (but provides strong ES guarantee)</span>

   T&amp; <span class="Statement">operator</span>[](<span class="Type">long</span> i) <span class="Type">const</span>;
   <span class="Comment">// accesses ith element in the array (currently no range checking)</span>

   T* get() <span class="Type">const</span>;
   <span class="Comment">// get raw pointer</span>

   T* release();
   <span class="Comment">// get raw pointer and reset to null</span>

   <span class="Type">void</span> move(UniqueArray&amp; other);
   <span class="Comment">// move raw pointer</span>

   <span class="Type">void</span> swap(UniqueArray&amp; other);
   <span class="Comment">// swap raw pointer</span>

   UniqueArray&amp; <span class="Statement">operator</span>=(fake_null_type);
   UniqueArray(fake_null_type);
   <span class="Comment">// allows initialization and assignment of 0</span>

   <span class="Statement">operator</span> fake_null_type() <span class="Type">const</span>;
   <span class="Comment">// allows comparison to 0</span>

};



<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(UniqueArray&lt;T&gt;&amp; p, UniqueArray&lt;T&gt;&amp; q);



<span class="Comment">// Equality testing</span>

<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>==(<span class="Type">const</span> UniqueArray&lt;X&gt;&amp; a, <span class="Type">const</span> UniqueArray&lt;X&gt;&amp; b);
<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>!=(<span class="Type">const</span> UniqueArray&lt;X&gt;&amp; a, <span class="Type">const</span> UniqueArray&lt;X&gt;&amp; b);




<span class="Comment">/*</span><span class="Comment">*********************************************************************</span>

<span class="Comment">Unique2DArray&lt;T&gt; -- unique pointer to array of arrays.</span>

<span class="Comment">This is very similar to UniqueArray&lt; UniqueArray&lt;T&gt; &gt;, except that </span>
<span class="Comment">we can retrofit old code that accepts objects of type T**.</span>

<span class="Comment">Constructors:</span>
<span class="Comment">   Unique2DArray&lt;T&gt; p1;     // initialize with null</span>

<span class="Comment">   p1 = 0;              // destroy's p1's referent and assigns null</span>
<span class="Comment">   p1.reset();</span>

<span class="Comment">   p1.SetLength(n);     // destroy's p1's referent and assigns</span>
<span class="Comment">                        // a fresh array of null pointers</span>

<span class="Comment">   p1.SetDims(n, m)     // creates an n x m array</span>
<span class="Comment">                </span>
<span class="Comment">   if (!p1) ...         // test for null</span>
<span class="Comment">   if (p1 == 0) ...</span>

<span class="Comment">   if (p1) ...          // test for nonnull</span>
<span class="Comment">   if (p1 != 0) ...</span>

<span class="Comment">   if (p1 == p2) ...    // test for equality</span>
<span class="Comment">   if (p1 != p2) ...   </span>

<span class="Comment">   p1[i]                // array indexing</span>

<span class="Comment">   T **rp;</span>
<span class="Comment">   rp = p1.get();       // fetch raw pointer</span>
<span class="Comment">   rp = p1.release();   // fetch raw pointer, and set to null</span>
<span class="Comment">   p1.move(p2);         // if p1 != p2 then:</span>
<span class="Comment">                        //    makes p1 point to p2's referent,</span>
<span class="Comment">                        //    setting p2 to null and destroying</span>
<span class="Comment">                        //    p1's referent</span>

<span class="Comment">   p1.swap(p2);         // fast swap</span>
<span class="Comment">   swap(p1, p2);</span>

<span class="Comment">   </span>
<span class="Comment">*********************************************************************</span><span class="Comment">*/</span>


<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt;
<span class="Type">class</span> Unique2DArray {
<span class="Statement">public</span>:
   <span class="Type">typedef</span> T *T_ptr;

   Unique2DArray();
   <span class="Comment">// initially null</span>

   ~Unique2DArray();
   <span class="Comment">// destroys the entire array and each row in the array</span>

   <span class="Type">void</span> reset();
   <span class="Comment">// reset to null</span>


   <span class="Type">void</span> SetLength(<span class="Type">long</span> n);
   <span class="Comment">// resets the array to a vector of length n,</span>
   <span class="Comment">// each entry initialized to null.</span>
   <span class="Comment">// EXCEPTIONS: may throw (provides strong ES guarantee)</span>

   <span class="Type">void</span> SetDims(<span class="Type">long</span> n, <span class="Type">long</span> m);
   <span class="Comment">// resets the array to a 2D array with n rows and m columns.</span>
   <span class="Comment">// EXCEPTIONS: may throw (provides strong ES guarantee)</span>

   <span class="Type">void</span> SetDimsFrom1(<span class="Type">long</span> n, <span class="Type">long</span> m);
   <span class="Comment">// same as above, but only initializes rows 1..n-1.</span>
   <span class="Comment">// this helps with some legacy code.</span>
   <span class="Comment">// EXCEPTIONS: may throw (provides strong ES guarantee)</span>

   T_ptr&amp; <span class="Statement">operator</span>[](<span class="Type">long</span> i) <span class="Type">const</span>;
   <span class="Comment">// array indexing, no range checking</span>

   T_ptr* get() <span class="Type">const</span>;
   <span class="Comment">// return underlying pointer</span>

   T_ptr* release() { len = <span class="Constant">0</span>; <span class="Statement">return</span> dp.release(); }
   <span class="Comment">// return underlying pointer and reset to null</span>


   <span class="Type">void</span> move(Unique2DArray&amp; other);
   <span class="Comment">// move pointers</span>

   <span class="Type">void</span> swap(Unique2DArray&amp; other);
   <span class="Comment">// swap pointers</span>

   Unique2DArray&amp; <span class="Statement">operator</span>=(fake_null_type);
   Unique2DArray(fake_null_type) : dp(<span class="Constant">0</span>), len(<span class="Constant">0</span>) { }
   <span class="Comment">// allows initialization and assignment of 0</span>

   <span class="Statement">operator</span> fake_null_type() <span class="Type">const</span>;
   <span class="Comment">// allows comparison to 0</span>

};


<span class="Comment">// free swap function</span>
<span class="Type">template</span>&lt;<span class="Type">class</span> T&gt; <span class="Type">void</span> swap(Unique2DArray&lt;T&gt;&amp; p, Unique2DArray&lt;T&gt;&amp; q);



<span class="Comment">// Equality testing</span>

<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>==(<span class="Type">const</span> Unique2DArray&lt;X&gt;&amp; a, <span class="Type">const</span> Unique2DArray&lt;X&gt;&amp; b);
<span class="Type">template</span>&lt;<span class="Type">class</span> X&gt; <span class="Type">bool</span> <span class="Statement">operator</span>!=(<span class="Type">const</span> Unique2DArray&lt;X&gt;&amp; a, <span class="Type">const</span> Unique2DArray&lt;X&gt;&amp; b);



</pre>
</body>
</html>
